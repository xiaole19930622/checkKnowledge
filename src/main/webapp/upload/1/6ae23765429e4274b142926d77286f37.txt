SELECT
	kn.`name`,
	kn.number,
	sk.know_name,
	sk.know_number,
  kn.id as 'kid',
  sk.id  as 'sid'
FROM
	knowledge kn
INNER JOIN sysn_knowledge sk ON concat(
	kn.section,
	kn.number,
	kn.`name`,
	kn.`subject`
) = concat(
	sk.section,
	sk.know_number,
	sk.know_name,
	sk.`subject`
)



// 关联存储过程
CREATE PROCEDURE `updata_sysnKnow2` ()
BEGIN
DECLARE  no_more_record INT DEFAULT 0;
  DECLARE knowid int ;
  DECLARE sysnid int;
 DECLARE  cur_record CURSOR FOR  
SELECT
  kn.id as 'kid',
  sk.id  as 'sid'
FROM
	knowledge kn
INNER JOIN sysn_knowledge sk ON concat(
	kn.section,
	kn.number,
	kn.`name`,
	kn.`subject`
) = concat(
	sk.section,
	sk.know_number,
	sk.know_name,
	sk.`subject`
);
/*首先这里对游标进行定义*/
 DECLARE  CONTINUE HANDLER FOR NOT FOUND  SET  no_more_record = 1; /*这个是个条件处理,针对NOT FOUND的条件,当没有记录时赋值为1*/

 OPEN  cur_record; /*接着使用OPEN打开游标*/
 FETCH  cur_record INTO knowid ,sysnid; /*把第一行数据写入变量中,游标也随之指向了记录的第一行*/

 WHILE no_more_record != 1 DO
 UPDATE sysn_knowledge SET know_id = knowid where id = sysnid;
 FETCH  cur_record INTO knowid, sysnid;

 END WHILE;
 CLOSE  cur_record;  /*用完后记得用CLOSE把资源释放掉*/
END